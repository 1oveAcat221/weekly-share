# Java 异常

在 C 和其他早期的编程语言中，对于错误的处理通常是返回某个特定值或者设置某个标致，并且假定接受者会对这个返回值或者标致进行检查。但是在实践过程中，每次在调用方法的时候都进行全面的错误检查会使代码变得难以阅读，并且由于不是强制的，程序员不去检查错误的情形也不足为奇。  
解决的办法是用强制规定的形式来消除对于错误处理随心所欲的因素，这种异常处理的实现可以追溯到上世纪60年代的操作系统，甚至是 BASIC 语言中的 `on error goto` 语句。C++ 中的异常处理机制基于 Ada，Java 的异常处理机制则建立在 C++ 的基础上。  
使用异常还有一个好处，它能够降低错误处理代码的重复和复杂度，如果不使用异常，则必须主动去检查特定的错误，并且需要在很多地方进行处理。如果使用了异常，就不需要在每个方法的调用处检查和处理错误，异常可以在其他地方被统一的捕获和处理（异常处理程序）。这种方式不但降低了错误处理代码的重复，也将 *正常的执行过程* 与 *错误处理过程* 相分离，使代码更加易于阅读。  

## 抛出异常
异常情形是指阻止当前方法或作用域继续执行的问题，即当前场景中无法获取足够的信息来解决问题，这时所能做的就是从当前环境中跳出，并把问题交给上一级环境来处理。这就是抛出异常时所发生的事情。  

```java
if(t == null) {
    throw new NullPointerException();
}
```

抛出异常时，首先会使用 `new` 在堆中创建异常对象。然后当前的执行路径被终止（当前环境没有足够的信息解决这个问题，无法继续执行下去了），接着从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并会在一个恰当的地方来继续执行程序，这个地方就是异常处理程序（`catch` 块中的代码）。  
异常最重要的一点就是：如果发生了问题，它不会允许程序继续沿着正常的路径执行下去。在 C 语言中，如果程序员没有主动对返回的错误进行处理，会导致该问题会被忽略，从而使程序陷入一个不正确的状态中。而异常则会强制停止正常流程的执行，提供问题相关的信息，并强制程序处理这个问题，使程序回到正确的状态。  

Java 中，可以抛出任意类型的 `Throwable` 对象，它是异常类型的根类。通常对于不同类型的错误要抛出相应类型的异常。错误信息可以包含在异常对象内部或者异常类的名称来暗示。上层环境通过这些信息来决定如何处理异常。  

## 捕获异常
异常和返回值类似的地方是他们都是从方法中返回的，都标志着当前作用域的退出。但他们最关键的不同是他们返回的地点不同，返回值返回的地点是上层调用栈，而异常的返回地点可能与异常抛出的地点很远，可能跨越方法调用栈的许多层次。  

异常的捕获使用的是 `try-catch` 语句实现的，首先是 `try` 块，其中的是可能会产生异常的代码，这个区域被称作监控区域（guarded region）。`try` 块之后紧跟的是异常处理代码，这些代码会被放入 `catch` 块中。被抛出的异常必须在某个地方得到处理，这个地方就是 `catch` 块中的异常处理程序，紧跟在 `try` 块之后。  

```java
try {
    // 可能产生异常的代码
} catch(Type1 id1) {
    // Type1 类型异常的处理代码
} catch(Type2 id2) {
    // Type2 类型异常的处理代码
}
```

每个 `catch` 子句都接收一个特定类型的异常，当异常被抛出时，异常处理机制负责寻找参数与该异常类型匹配的第一个处理程序。然后进入 `catch` 子句执行，一旦 `catch` 子句结束，则认为此时异常以及得到处理，异常的处理过程结束，程序会回到正常的流程中。这里和 `switch` 很像，但是不同的是 `switch` 语句需要在每一个 `case` 后面加一个 `break` 才能避免执行后面的 `case` 语句，而 `catch` 仅会执行匹配的子句。  

在匹配异常时，不要求完全匹配异常的类型，子类型的异常也能够匹配父类型的 `catch` 子句，正因为如此，我们不需要再子句中使用 `instanceof` 关键字判断异常的具体类型了。并且，对于匹配子类型的 `catch` 子句需要放到匹配父类型的 `catch` 子句之前，防止父类型的 `catch` 子句将所有异常都截获，导致后面子类型的 `catch` 子句永远不会被执行。  

## Java 标准异常
![](_v_images/20200815154650865_17778.png =600x)  

Java 中的异常体系如上图所示，以 `Throwable` 类为根，是所有异常的基类，其有两个子类，`Error` 和 `Exception`。  

- `Error` 表示系统错误或资源耗尽，由Java系统自己使用，应用程序不应抛出和处理，比如图中列出的虚拟机错误(VirtualMacheError)及其子类内存溢出错误(`OutOfMemoryError`)和栈溢出错误(`StackOverflowError`)。
- `Exception`表示应用程序错误，它有很多子类，应用程序也可以通过继承`Exception`或其子类创建自定义异常，图中列出了三个直接子类：`IOException` (输入输出 I/O 异常)，`SQLException` (数据库 SQL 异常)，`RuntimeException` (运行时异常)。

`RuntimeException` **比较特殊，它的名字有点误导，因为其他异常也是运行时产生的，它表示的实际含义是unchecked exception (未受检异常)，Error及其子类也是unchecked exception。相对而言，Exception的其他子类和Exception自身则是checked exception (受检查的异常)。**  

*什么是 checked 和 unchecked exception 见下节。*   

以下是一些常见的 `RuntimeException` 的子类：

- NullPointerException：空指针异常
- IllegalStateException：非法状态
- ClassCastException：非法强制类型转换
- IllegalArgumentException：参数错误
- NumberFormatException：数字格式错误
- IndexOutOfBoundsException：索引越界
- ArrayIndexOutOfBoundsException：数组索引越界
- StringIndexOutOfBoundsException：字符串索引越界

这么多不同的异常类其实并没有比Throwable这个基类多多少属性和方法，大部分类在继承父类后只是定义了几个构造方法，这些构造方法也只是调用了父类的构造方法，并没有额外的操作。那为什么定义这么多不同的类呢？主要是为了名字不同，**异常类的名字本身就代表了异常的关键信息，无论是抛出还是捕获异常时，使用合适的名字都有助于代码的可读性和可维护性。**  

## 异常说明
Java 鼓励将方法可能抛出的异常告知使用此方法的用户，Java 提供了相应的语法，使用户能够在不需要查看源代码的情况下能够知道该方法可能抛出的异常类型。这就是 *异常说明*，属于方法声明的一部分，紧跟在形式参数列表之后。  

```java
void f() throws TooBig, TooSmall, DivZero {
    ...
}
```

**Java 中仅强制要求程序员提供受检查的异常说明，对于未受检查的异常，是可以在方法未声明的情况下抛出的。如果方法内抛出了没有事先说明的受检查的异常，编译时会出现编译错误。**

> 我们自己定义异常的时候应该使用 checked 还是 unchecked exception 呢？  
> 
> 对于这个问题，业界有各种各样的观点和争论，没有特别一致的结论。  
> 
> 一种普遍的说法是，RuntimeException (unchecked) 表示编程的逻辑错误，编程时应该检查以避免这些错误，比如说像空指针异常，如果真的出现了这些异常，程序退出也是正常的，程序员应该检查程序代码的bug而不是想办法处理这种异常。Checked exception 表示程序本身没问题，但由于 I/O、网络、数据库等其他不可预测的错误导致的异常，调用者应该进行适当处理。  
> 
> 但其实编程错误也是应该进行处理的，尤其是，**Java 被广泛应用于服务器程序中，不能因为一个逻辑错误就使程序退出。所以，目前一种更被 认同的观点是，Java 中的这个区分是没有太大意义的，可以统一使用 RuntimeException 即 unchcked exception 来代替。**  
> 
> 这个观点的基本理由是，无论是 checked 还是 unchecked 异常，无论是否出现在 throws 声明（即异常说明）中，我们都应该在合适的地方以适当的方式进行处理，而不是只为了满足编译器的要求，盲目处理异常，既然都要进行处理异常，checked exception 的强制声明和处理就显得啰嗦，尤其是在调用层次比较深的情况下。  
> 
> **其实观点本身并不太重要，更重要的是一致性，一个项目中，应该对如何使用异常达成一致，按照约定使用即可。Java 中已有的异常和类库也已经在哪里，我们还是要按照他们的要求进行使用。**  

## 异常链
有时我们需要在捕获一个异常之后将其重新抛出，或者抛出另外一个异常，同时希望将原来的异常信息保存下来，所有异常都像被穿在一条链子上一样，这被称为*异常链*。在 JDK 1.4 之后，`Throwable` 的子类都可以接受一个 `Throwable cause` 对象作为参数、这个 `cause` 就表示原始异常，这样可以将原始异常传递给新的异常，这样即使重新抛出了新的异常，也能通过这个异常链追踪到最初的异常。  

```java
try {
    // 可能触发异常的代码
} catch(NumberFormatException e) {
    // 抛出新的异常
    throw new AppException("输入格式不正确", e);
} catch(Exception e) {
    // 抛出原来的异常
    throw e;
}
```

值得注意的是，`Throwable` 只有三个子类提供了带 `Throwable cause` 参数的构造器（`Error`、`Exception` 和 `RuntimeException`），其他异常如果想链接原始异常，则需要通过 `initCause()` 方法。外层捕获异常之后，可以通过 `getCause()` 方法提取出原始异常进行处理。  

对于异常的重新抛出，可能是因为当前的代码无法完成该异常的处理，需要上层环境进行进一步处理。而对于抛出新的异常，可能是因为原始异常包含的信息不够，需要补充一些信息；也可能是原始异常太过于底层，不方便调用者理解和处理。如果调用者希望知道原始异常的细节，可以通过 `getCause()` 方法获取原始异常。  

## finally 语句
`finally` 语句紧跟在 `catch` 语句之后，无论 `try` 块内有无异常产生其内部的代码都会执行。  

```java
try{
    //可能抛出异常
}catch(Exception e){
    //捕获异常
}finally{
    //不管有无异常都执行
}
```

具体分为三种情况，这三种情况下 `finally` 块中的语句都会执行：

- 如果没有异常发生，在try内的代码执行结束后执行
- 如果有异常发生且被catch捕获，在catch内的代码执行结束后执行
- 如果有异常发生但没被捕获，则在异常被抛给上层之前执行

由于 `finally` 语句的特点，其内部通常用于释放资源，如网络连接，文件流等。

`finally` 语句有一个执行细节，如果在try或者catch语句内有return语句，则return语句在finally语句执行结束后才执行，但finally并不能改变返回值。例如如下代码：  

```java
public static int test(){
    int ret = 0;
    try{
        return ret;
    }finally{
        ret = 2;
    }
}
```

该方法的返回值是0，而不是2，实际执行过程是，在执行到try内的return ret;语句前，会先将返回值ret保存在一个临时变量中，然后才执行finally语句，最后try再返回那个临时变量，finally中对ret的修改不会被返回。  

那么，如果 `finally` 块中有 `return` 语句呢？例如下面的代码：  

```java
public static int test() {
    int ret = 0;
    try {
        int a = 5 / 0;
        return ret;
    } finally {
        return 2;
    }
}
```

该方法的返回值是 2，这是由于代码在 `try` 块中先触发了异常，正常的执行流程被中止了。并且原来在 `try` 块中触发的异常也会丢失，方法正常返回，就像没有发生异常一样。并且，如果 `finally` 中抛出了异常，则原来的异常也会丢失。**一般情况下，为了防止异常的丢失，应避免在 `finally` 块中使用 `return` 语句或者抛出异常。如果其内部调用的方法可能产生异常，则应该捕获异常进行处理。**  

